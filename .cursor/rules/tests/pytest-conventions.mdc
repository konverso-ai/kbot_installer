---
description: Pytest testing conventions and best practices
globs: test_*.py,*_test.py
---

# Pytest Testing Conventions

## Test Structure Requirements

### Package Test Organization
- **Every package must have a `tests/` directory**
- **One test module per package module**: `test_module_name.py` for each `module_name.py`
- **Test files must be named**: `test_*.py` or `*_test.py`
- **Test classes must be named**: `TestClassName`
- **Test functions must be named**: `test_function_name`

### Example Structure
```
my_package/
├── __init__.py
├── user_service.py
├── payment_processor.py
└── tests/
    ├── __init__.py
    ├── test_user_service.py
    └── test_payment_processor.py
```

## Pytest Best Practices

### Always Use pytest
- **Never use unittest** - always use pytest
- **Use pytest fixtures** for setup/teardown
- **Use pytest.mark.parametrize** extensively for multiple test cases
- **Keep test content simple and focused**

### Parametrize for Multiple Cases
```python
import pytest

@pytest.mark.parametrize("input_value,expected", [
    (1, 2),
    (2, 4),
    (3, 6),
    (0, 0),
])
def test_double_function(input_value, expected):
    """Test that double function works correctly."""
    result = double(input_value)
    assert result == expected
```

### Simple Test Content
```python
def test_user_creation():
    """Test user creation with valid data."""
    user = create_user("john", "john@example.com")
    assert user.name == "john"
    assert user.email == "john@example.com"
    assert user.is_active is True

@pytest.mark.parametrize("name,email,expected_active", [
    ("alice", "alice@example.com", True),
    ("bob", "bob@example.com", True),
    ("", "invalid@example.com", False),
    ("charlie", "", False),
])
def test_user_validation(name, email, expected_active):
    """Test user validation with various inputs."""
    user = create_user(name, email)
    assert user.is_active == expected_active
```

## Test File Template

### Basic Test Module
```python
"""Tests for module_name module."""

import pytest
from module_name import ClassName, function_name


class TestClassName:
    """Test cases for ClassName."""
    
    def test_initialization(self):
        """Test class initialization."""
        obj = ClassName("test")
        assert obj.value == "test"
    
    @pytest.mark.parametrize("input_val,expected", [
        ("value1", "result1"),
        ("value2", "result2"),
    ])
    def test_method(self, input_val, expected):
        """Test method with various inputs."""
        obj = ClassName("test")
        result = obj.method(input_val)
        assert result == expected


def test_function_name():
    """Test function_name function."""
    result = function_name("input")
    assert result == "expected_output"

@pytest.mark.parametrize("input,expected", [
    ("case1", "result1"),
    ("case2", "result2"),
])
def test_function_with_cases(input, expected):
    """Test function with multiple cases."""
    result = function_name(input)
    assert result == expected
```

## Pytest Markers

### Common Markers
```python
@pytest.mark.parametrize("param", [1, 2, 3])
def test_with_params(param):
    """Test with parameters."""
    pass

@pytest.mark.skip(reason="Not implemented yet")
def test_skipped():
    """Test that is skipped."""
    pass

@pytest.mark.xfail(reason="Known issue")
def test_expected_failure():
    """Test that is expected to fail."""
    pass

@pytest.mark.slow
def test_slow_operation():
    """Test that takes a long time."""
    pass
```

## Fixtures

### Simple Fixtures
```python
@pytest.fixture
def sample_user():
    """Create a sample user for testing."""
    return User("test_user", "test@example.com")

@pytest.fixture
def empty_database():
    """Create an empty database for testing."""
    db = Database()
    yield db
    db.cleanup()
```

## Assertions

### Use Simple Assertions
```python
# Good - simple and clear
assert result == expected
assert user.is_active is True
assert len(items) == 3

# Good - with descriptive messages
assert result == expected, f"Expected {expected}, got {result}"

# Avoid complex assertions
# Bad: assert (a == b and c == d) or (e == f)
```

## Test Organization

### Group Related Tests
```python
class TestUserService:
    """Test cases for UserService."""
    
    def test_create_user(self):
        """Test user creation."""
        pass
    
    def test_update_user(self):
        """Test user update."""
        pass
    
    def test_delete_user(self):
        """Test user deletion."""
        pass
```

## Running Tests

### Command Line
```bash
# Run all tests
uv run pytest

# Run specific test file
uv run pytest tests/test_user_service.py

# Run with verbose output
uv run pytest -v

# Run with coverage
uv run pytest --cov=my_package

# Run specific test
uv run pytest tests/test_user_service.py::test_create_user
```

## Requirements

1. **Always use pytest** - never unittest
2. **One test module per package module**
3. **Use pytest.mark.parametrize extensively**
4. **Keep test content simple and focused**
5. **Use descriptive test names**
6. **Group related tests in classes**
7. **Use fixtures for setup/teardown**
8. **Write clear, simple assertions**